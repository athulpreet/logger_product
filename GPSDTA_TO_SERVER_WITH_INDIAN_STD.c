/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program for GPS Tracker with MQTT reporting.
  ******************************************************************************
  * @attention
  *
  * This firmware integrates two main functionalities into a FreeRTOS application:
  * 1.  A GPS Task that listens on UART5 for NMEA sentences, parses them to
  * extract location, speed, and time, and stores the data securely.
  * 2.  An MQTT Task that manages a cellular modem on UART4 to connect to the
  * internet and publish the GPS data to a remote server every second.
  *
  * The system uses DMA with idle-line interrupts for efficient, non-blocking
  * UART communication. It is designed to be robust, with automatic reconnection
  * and modem power-cycling logic to handle network errors gracefully.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"
#include "usart.h"
#include "gpdma.h"
#include "gpio.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "FreeRTOS.h"
#include "task.h"
#include "queue.h"
#include "semphr.h"
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <stdarg.h>
#include <stdlib.h>
#include <math.h>
#include <ctype.h> // For isdigit
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */
typedef struct {
    float latitude;
    float longitude;
    float altitude;
    float speed_knots;
    float course_degrees;
    char time[12];
    bool is_valid;
} gps_data_t;
/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
// --- Buffer Sizes ---
#define UART4_RX_BUFFER_SIZE 256 // For Modem
#define GPS_DMA_RX_BUFFER_SIZE 512 // For GPS
#define MAX_NMEA_SENTENCE_LEN 100

// --- Modem Power Cycle Configuration ---
#define MODEM_PWR_RST_GPIO_Port GPIOC
#define MODEM_PWR_RST_Pin GPIO_PIN_6

// --- Debug Logging Configuration ---
#define DEBUG_ENABLED 1
#define DEBUG_LOG_QUEUE_LEN 15
#define DEBUG_LOG_MAX_MSG_LEN 300 // Increased for larger JSON payloads
#define UART4_RX_QUEUE_LEN 5
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */
#if DEBUG_ENABLED
#define DEBUG_PRINTF(...) log_message(__VA_ARGS__)
#else
#define DEBUG_PRINTF(...)
#endif
/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
// These are defined in usart.c, generated by CubeMX
extern UART_HandleTypeDef huart2; // Debug
extern UART_HandleTypeDef huart4; // Modem
extern UART_HandleTypeDef huart5; // GPS

/* USER CODE BEGIN PV */
// --- MQTT Configuration ---
char g_mqtt_broker_ip[40] = "3.109.116.92";
char g_mqtt_broker_port[6] = "1883";
char g_mqtt_client_id[32] = "spring-client";
char g_mqtt_username[32] = "Thinture";
char g_mqtt_password[32] = "Thinture24";
char g_mqtt_topic[32] = "Test";

// --- RTOS Handles ---
QueueHandle_t g_debug_log_queue;
QueueHandle_t g_uart4_rx_queue;
SemaphoreHandle_t g_gps_data_ready_sem;
SemaphoreHandle_t g_gps_data_mutex;

// --- Global Data Structures ---
gps_data_t g_gps_data = {0};

// --- Buffers and State Variables ---
uint8_t g_uart4_dma_rx_buffer[UART4_RX_BUFFER_SIZE];
uint8_t g_gps_dma_rx_buffer[GPS_DMA_RX_BUFFER_SIZE];
volatile uint16_t g_gps_bytes_received = 0;
/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
/* USER CODE BEGIN PFP */
void vDebugLogTask(void *pvParameters);
void vMqttTask(void *pvParameters);
void vGpsTask(void *pvParameters);
void log_message(const char* format, ...);
bool send_and_wait_for_response(const char* cmd, const char* expected_response, uint32_t timeout_ms);
void perform_modem_power_cycle(void);
void parse_gnrmc(char* gnrmc_sentence);
void parse_gngga(char* gngga_sentence);
float nmea_to_decimal(float nmea_coord, char direction);
void process_gps_buffer(uint8_t* buffer, uint16_t size);
double atof_custom(const char *s);
void format_coord(char* buffer, size_t buffer_size, float coord, char positive_dir, char negative_dir);
void convert_utc_to_ist(const char* utc_time, char* ist_time_buffer, size_t buffer_size);
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

#if DEBUG_ENABLED
void log_message(const char* format, ...) {
    char log_buffer[DEBUG_LOG_MAX_MSG_LEN];
    va_list args;
    va_start(args, format);
    int len = vsnprintf(log_buffer, sizeof(log_buffer), format, args);
    va_end(args);

    if (len > 0 && g_debug_log_queue != NULL) {
        char* msg_to_send = pvPortMalloc(len + 1);
        if (msg_to_send != NULL) {
            strncpy(msg_to_send, log_buffer, len);
            msg_to_send[len] = '\0';
            if (xQueueSend(g_debug_log_queue, &msg_to_send, (TickType_t)0) != pdPASS) {
                vPortFree(msg_to_send);
            }
        }
    }
}

void vDebugLogTask(void *pvParameters) {
    char* msg_ptr;
    log_message("--- RTOS Logging Task Initialized ---\r\n");
    for (;;) {
        if (xQueueReceive(g_debug_log_queue, &msg_ptr, portMAX_DELAY) == pdPASS) {
            if (msg_ptr != NULL) {
                HAL_UART_Transmit(&huart2, (uint8_t*)msg_ptr, strlen(msg_ptr), HAL_MAX_DELAY);
                vPortFree(msg_ptr);
            }
        }
    }
}
#endif // DEBUG_ENABLED

/**
 * @brief Converts a UTC time string (HHMMSS) to an IST time string (HH:MM:SS).
 */
void convert_utc_to_ist(const char* utc_time, char* ist_time_buffer, size_t buffer_size) {
    if (utc_time == NULL || strlen(utc_time) < 6) {
        strncpy(ist_time_buffer, "00:00:00", buffer_size - 1);
        ist_time_buffer[buffer_size - 1] = '\0';
        return;
    }

    // Parse HH, MM, SS from the UTC string
    char hh_str[3] = {utc_time[0], utc_time[1], '\0'};
    char mm_str[3] = {utc_time[2], utc_time[3], '\0'};
    char ss_str[3] = {utc_time[4], utc_time[5], '\0'};
    int utc_h = atoi(hh_str);
    int utc_m = atoi(mm_str);
    int utc_s = atoi(ss_str);

    // Add 5 hours 30 minutes for IST offset
    int ist_h = utc_h + 5;
    int ist_m = utc_m + 30;

    // Handle minute rollover
    if (ist_m >= 60) {
        ist_m -= 60;
        ist_h += 1;
    }

    // Handle hour rollover (day change)
    if (ist_h >= 24) {
        ist_h -= 24;
    }

    // Format the result into the buffer
    snprintf(ist_time_buffer, buffer_size, "%02d:%02d:%02d", ist_h, ist_m, utc_s);
}


/**
 * @brief Formats a float coordinate into the required string format DDD.DDDDDDD[C].
 */
void format_coord(char* buffer, size_t buffer_size, float coord, char positive_dir, char negative_dir) {
    char dir = (coord >= 0) ? positive_dir : negative_dir;
    float coord_abs = fabsf(coord);
    int degrees = (int)coord_abs;
    unsigned long frac = (unsigned long)((coord_abs - degrees) * 10000000L);
    if (frac > 9999999) frac = 9999999;
    snprintf(buffer, buffer_size, "%03d.%07lu%c", degrees, frac, dir);
}


/**
 * @brief Custom string-to-float conversion function.
 */
double atof_custom(const char *s)
{
    double a = 0.0;
    int e = 0;
    int c;
    if (!s) return 0.0;
    while ((c = *s++) != '\0' && (c >= '0' && c <= '9')) {
        a = a*10.0 + (c - '0');
    }
    if (c == '.') {
        while ((c = *s++) != '\0' && (c >= '0' && c <= '9')) {
            a = a*10.0 + (c - '0');
            e = e-1;
        }
    }
    while (e < 0) {
        a *= 0.1;
        e++;
    }
    return a;
}


/**
 * @brief Performs a hardware power cycle on the cellular modem.
 */
void perform_modem_power_cycle(void) {
    DEBUG_PRINTF("--- Performing Modem Power Cycle ---\r\n");
    DEBUG_PRINTF("Powering modem OFF...\r\n");
    HAL_GPIO_WritePin(MODEM_PWR_RST_GPIO_Port, MODEM_PWR_RST_Pin, GPIO_PIN_RESET);
    vTaskDelay(pdMS_TO_TICKS(2000));
    DEBUG_PRINTF("Powering modem ON...\r\n");
    HAL_GPIO_WritePin(MODEM_PWR_RST_GPIO_Port, MODEM_PWR_RST_Pin, GPIO_PIN_SET);
    DEBUG_PRINTF("--- Modem Power Cycle Complete. Waiting for boot... ---\r\n");
    vTaskDelay(pdMS_TO_TICKS(12000));
}

/**
 * @brief Converts NMEA coordinate format to decimal degrees.
 */
float nmea_to_decimal(float nmea_coord, char direction) {
    if (nmea_coord == 0.0f) {
        return 0.0f;
    }
    int degrees = (int)(nmea_coord / 100.0f);
    double minutes = nmea_coord - (degrees * 100.0f);
    double decimal_degrees = degrees + (minutes / 60.0f);
    if (direction == 'S' || direction == 'W') {
        decimal_degrees = -decimal_degrees;
    }
    return (float)decimal_degrees;
}

/**
 * @brief Parses a GNGGA NMEA sentence to extract altitude.
 */
void parse_gngga(char* gngga_sentence) {
    char temp_sentence[MAX_NMEA_SENTENCE_LEN];
    strncpy(temp_sentence, gngga_sentence, sizeof(temp_sentence) - 1);
    temp_sentence[sizeof(temp_sentence) - 1] = '\0';

    char* fields[15] = {NULL};
    int field_count = 0;
    char *saveptr; // For strtok_r
    char* token = strtok_r(temp_sentence, ",*", &saveptr);
    while(token != NULL && field_count < 15) {
        fields[field_count++] = token;
        token = strtok_r(NULL, ",*", &saveptr);
    }

    if (field_count >= 10 && fields[9] != NULL && strlen(fields[9]) > 0) {
        float altitude = atof_custom(fields[9]);
        if (xSemaphoreTake(g_gps_data_mutex, pdMS_TO_TICKS(100)) == pdTRUE) {
            g_gps_data.altitude = altitude;
            xSemaphoreGive(g_gps_data_mutex);
        }
    }
}

/**
 * @brief Parses a GNRMC NMEA sentence to update GPS data.
 */
void parse_gnrmc(char* gnrmc_sentence) {
    char temp_sentence[MAX_NMEA_SENTENCE_LEN];
    gps_data_t new_data = {0};

    strncpy(temp_sentence, gnrmc_sentence, sizeof(temp_sentence) - 1);
    temp_sentence[sizeof(temp_sentence) - 1] = '\0';

    char* fields[15] = {NULL};
    int field_count = 0;
    char *saveptr; // For strtok_r
    char* token = strtok_r(temp_sentence, ",*", &saveptr);
    while(token != NULL && field_count < 15) {
        fields[field_count++] = token;
        token = strtok_r(NULL, ",*", &saveptr);
    }

    if (field_count >= 7 && fields[2] != NULL && fields[2][0] == 'A' &&
        fields[3] != NULL && strlen(fields[3]) > 4 &&
        fields[5] != NULL && strlen(fields[5]) > 5)
    {
        new_data.is_valid = true;
        if (fields[1] != NULL && strlen(fields[1]) < sizeof(new_data.time)) strncpy(new_data.time, fields[1], sizeof(new_data.time) - 1);
        new_data.latitude = nmea_to_decimal(atof_custom(fields[3]), fields[4][0]);
        new_data.longitude = nmea_to_decimal(atof_custom(fields[5]), fields[6][0]);
        if (fields[7] != NULL) new_data.speed_knots = atof_custom(fields[7]);
        if (field_count >= 9 && fields[8] != NULL) new_data.course_degrees = atof_custom(fields[8]);
    } else {
        new_data.is_valid = false;
    }

    if (xSemaphoreTake(g_gps_data_mutex, pdMS_TO_TICKS(100)) == pdTRUE) {
        if (new_data.is_valid) {
            new_data.altitude = g_gps_data.altitude; // Preserve altitude
            g_gps_data = new_data;
        } else {
            g_gps_data.is_valid = false;
        }
        xSemaphoreGive(g_gps_data_mutex);
    }
}

/**
 * @brief Processes the raw GPS DMA buffer to find and parse NMEA sentences.
 */
void process_gps_buffer(uint8_t* buffer, uint16_t size) {
    static char nmea_sentence[MAX_NMEA_SENTENCE_LEN];
    static uint16_t sentence_index = 0;
    if (buffer == NULL || size == 0) return;

    for (uint16_t i = 0; i < size; i++) {
        char ch = (char)buffer[i];
        if (ch == '$') sentence_index = 0;

        if (sentence_index < (sizeof(nmea_sentence) - 1)) {
            nmea_sentence[sentence_index++] = ch;
        }

        if (ch == '\n') {
            nmea_sentence[sentence_index] = '\0';
            if (strncmp(nmea_sentence, "$GNRMC", 6) == 0) parse_gnrmc(nmea_sentence);
            else if (strncmp(nmea_sentence, "$GNGGA", 6) == 0) parse_gngga(nmea_sentence);
            sentence_index = 0;
        }
    }
}

/**
 * @brief RTOS task for handling all GPS-related processing.
 */
void vGpsTask(void *pvParameters) {
    DEBUG_PRINTF("--- GPS Task Started. Listening on UART5... ---\r\n");
    __HAL_UART_CLEAR_FLAG(&huart5, UART_CLEAR_OREF);
    HAL_UARTEx_ReceiveToIdle_DMA(&huart5, g_gps_dma_rx_buffer, GPS_DMA_RX_BUFFER_SIZE);

    while(1) {
        if (xSemaphoreTake(g_gps_data_ready_sem, portMAX_DELAY) == pdTRUE) {
            if (g_gps_bytes_received > 0) {
                process_gps_buffer(g_gps_dma_rx_buffer, g_gps_bytes_received);
            }
            memset(g_gps_dma_rx_buffer, 0, GPS_DMA_RX_BUFFER_SIZE);
            HAL_UARTEx_ReceiveToIdle_DMA(&huart5, g_gps_dma_rx_buffer, GPS_DMA_RX_BUFFER_SIZE);
        }
    }
}

/**
  * @brief  Reception Event Callback for all UARTs.
  */
void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size) {
    if (huart->Instance == UART4) { // Modem
        BaseType_t xHigherPriorityTaskWoken = pdFALSE;
        uint8_t received_data[UART4_RX_BUFFER_SIZE + 1] = {0};
        memcpy(received_data, g_uart4_dma_rx_buffer, Size);
        xQueueSendFromISR(g_uart4_rx_queue, &received_data, &xHigherPriorityTaskWoken);
        HAL_UARTEx_ReceiveToIdle_DMA(&huart4, g_uart4_dma_rx_buffer, UART4_RX_BUFFER_SIZE);
        portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    } else if (huart->Instance == UART5) { // GPS
        g_gps_bytes_received = Size;
        BaseType_t xHigherPriorityTaskWoken = pdFALSE;
        xSemaphoreGiveFromISR(g_gps_data_ready_sem, &xHigherPriorityTaskWoken);
        portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    }
}

/**
  * @brief  UART error callback for all UARTs.
  */
void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart) {
    if (huart->Instance == UART4) { // Modem
        uint32_t error_code = HAL_UART_GetError(huart);
        DEBUG_PRINTF("!!! UART4 Error, code: 0x%lX. Restarting DMA. !!!\r\n", error_code);
        HAL_UART_AbortReceive(huart);
        HAL_UARTEx_ReceiveToIdle_DMA(huart, g_uart4_dma_rx_buffer, UART4_RX_BUFFER_SIZE);
    } else if (huart->Instance == UART5) { // GPS
        uint32_t error_code = HAL_UART_GetError(huart);
        DEBUG_PRINTF("!!! UART5 GPS Error, code: 0x%lX. Restarting DMA. !!!\r\n", error_code);
        HAL_UART_AbortReceive(huart);
        HAL_UARTEx_ReceiveToIdle_DMA(huart, g_gps_dma_rx_buffer, GPS_DMA_RX_BUFFER_SIZE);
    }
}

/**
 * @brief Sends a command and waits for a specific response from the modem.
 */
bool send_and_wait_for_response(const char* cmd, const char* expected_response, uint32_t timeout_ms) {
    uint8_t rx_buffer[UART4_RX_BUFFER_SIZE + 1];
    xQueueReset(g_uart4_rx_queue);
    DEBUG_PRINTF("CMD >> %s\r\n", cmd);
    HAL_UART_Transmit(&huart4, (uint8_t*)cmd, strlen(cmd), HAL_MAX_DELAY);

    TickType_t start_ticks = xTaskGetTickCount();
    while ((xTaskGetTickCount() - start_ticks) < pdMS_TO_TICKS(timeout_ms)) {
        if (xQueueReceive(g_uart4_rx_queue, &rx_buffer, pdMS_TO_TICKS(100)) == pdPASS) {
            // Don't print the whole buffer if it's just the payload
            if (strlen((char*)rx_buffer) < 50) {
                 DEBUG_PRINTF("RSP << %s\r\n", (char*)rx_buffer);
            }
            if (strstr((char*)rx_buffer, expected_response) != NULL) {
                return true;
            }
        }
    }
    DEBUG_PRINTF("ERROR: Timeout waiting for '%s'\r\n", expected_response);
    return false;
}

/**
 * @brief Main task to handle MQTT connection and publishing.
 */
void vMqttTask(void *pvParameters) {
    DEBUG_PRINTF("--- MQTT Task Started ---\r\n");
    char command_buffer[256];
    char mqtt_payload[512]; // Increased size for larger JSON
    uint8_t connection_retries = 0;
    const uint8_t max_retries = 3;

    vTaskDelay(pdMS_TO_TICKS(5000));
    __HAL_UART_CLEAR_FLAG(&huart4, UART_CLEAR_OREF);
    HAL_UARTEx_ReceiveToIdle_DMA(&huart4, g_uart4_dma_rx_buffer, UART4_RX_BUFFER_SIZE);
    perform_modem_power_cycle();

    DEBUG_PRINTF("Waiting for modem to respond...\r\n");
    while(!send_and_wait_for_response("AT\r\n", "OK", 1000)) {
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
    DEBUG_PRINTF("Modem is responsive.\r\n");

    while(1) {
        bool is_connected = false;
        while(!is_connected) {
            DEBUG_PRINTF("--- MQTT Connection Attempt #%d ---\r\n", connection_retries + 1);
            bool setup_ok = false;
            do {
                if (!send_and_wait_for_response("ATE0\r\n", "OK", 1000)) break;
                if (!send_and_wait_for_response("AT+CGATT=1\r\n", "OK", 8000)) break;
                vTaskDelay(pdMS_TO_TICKS(2000));
                send_and_wait_for_response("AT+CGACT=0,1\r\n", "OK", 8000);
                vTaskDelay(pdMS_TO_TICKS(500));
                snprintf(command_buffer, sizeof(command_buffer), "AT+CGDCONT=1,\"IP\",\"%s\"\r\n", "internet");
                if (!send_and_wait_for_response(command_buffer, "OK", 5000)) break;
                if (!send_and_wait_for_response("AT+CGACT=1,1\r\n", "OK", 10000)) break;
                vTaskDelay(pdMS_TO_TICKS(1000));
                snprintf(command_buffer, sizeof(command_buffer), "AT+QMTOPEN=0,\"%s\",%s\r\n", g_mqtt_broker_ip, g_mqtt_broker_port);
                if (!send_and_wait_for_response(command_buffer, "+QMTOPEN: 0,0", 20000)) break;
                vTaskDelay(pdMS_TO_TICKS(1000));
                snprintf(command_buffer, sizeof(command_buffer), "AT+QMTCONN=0,\"%s\",\"%s\",\"%s\"\r\n", g_mqtt_client_id, g_mqtt_username, g_mqtt_password);
                if (!send_and_wait_for_response(command_buffer, "+QMTCONN: 0,0,0", 20000)) break;
                setup_ok = true;
            } while(0);

            if (setup_ok) {
                is_connected = true;
                connection_retries = 0;
                DEBUG_PRINTF("\r\n--- MQTT Connection Successful ---\r\n\r\n");
            } else {
                DEBUG_PRINTF("\r\n--- MQTT Connection Failed ---\r\n");
                connection_retries++;
                if (connection_retries >= max_retries) {
                    DEBUG_PRINTF("!!! Max connection retries reached. Halting. !!!\r\n");
                    Error_Handler();
                }
                perform_modem_power_cycle();
            }
        }

        while(is_connected) {
            gps_data_t current_gps_data = {0};
            if (xSemaphoreTake(g_gps_data_mutex, pdMS_TO_TICKS(100)) == pdTRUE) {
                current_gps_data = g_gps_data;
                xSemaphoreGive(g_gps_data_mutex);
            }

            if (current_gps_data.is_valid) {
                char lat_str[25], lon_str[25], speed_str[4], course_str[4], timestamp_str[20];
                const char* vehicle_status = (current_gps_data.speed_knots < 2.0f) ? "IDLE" : "MOVING";

				char ist_time_str[9]; // HH:MM:SS
				convert_utc_to_ist(current_gps_data.time, ist_time_str, sizeof(ist_time_str));
				snprintf(timestamp_str, sizeof(timestamp_str), "2025-09-16 %s", ist_time_str);

                format_coord(lat_str, sizeof(lat_str), current_gps_data.latitude, 'N', 'S');
                format_coord(lon_str, sizeof(lon_str), current_gps_data.longitude, 'E', 'W');
                snprintf(speed_str, sizeof(speed_str), "%03d", (int)roundf(current_gps_data.speed_knots));
                snprintf(course_str, sizeof(course_str), "%03d", (int)roundf(current_gps_data.course_degrees));

                // Build payload using safe string concatenation to avoid stack issues
                strcpy(mqtt_payload, "{\"deviceID\":\"THIN0011\",\"IMEI\":\"864501070030500\",\"timestamp\":\"");
                strcat(mqtt_payload, timestamp_str);
                strcat(mqtt_payload, "\",\"dataValidity\":\"Valid\",\"status\":\"N1\",\"latitude\":\"");
                strcat(mqtt_payload, lat_str);
                strcat(mqtt_payload, "\",\"longitude\":\"");
                strcat(mqtt_payload, lon_str);
                strcat(mqtt_payload, "\",\"speed\":\"");
                strcat(mqtt_payload, speed_str);
                strcat(mqtt_payload, "\",\"course\":\"");
                strcat(mqtt_payload, course_str);
                strcat(mqtt_payload, "\",\"ignition\":\"IGon\",\"vehicleStatus\":\"");
                strcat(mqtt_payload, vehicle_status);
                strcat(mqtt_payload, "\",\"additionalData\":\"0000000000000\",\"timeIntervals\":\"002,010,002\",");
                strcat(mqtt_payload, "\"angleInterval\":\"015\",\"distanceInterval\":\"100\",\"gsmStrength\":\"073\",\"sequenceNumber\":\"Q263\"}");

            } else {
                 char timestamp_str[20];
                 snprintf(timestamp_str, sizeof(timestamp_str), "2025-09-16 00:00:00");
                 snprintf(mqtt_payload, sizeof(mqtt_payload),
                          "{\"deviceID\":\"THIN007\",\"IMEI\":\"864501070030566\","
                          "\"timestamp\":\"%s\",\"dataValidity\":\"Invalid\",\"status\":\"N1\","
                          "\"latitude\":\"\",\"longitude\":\"\",\"speed\":\"\",\"course\":\"\","
                          "\"ignition\":\"IGon\",\"vehicleStatus\":\"IDLE\",\"additionalData\":\"0100100000000\","
                          "\"timeIntervals\":\"002,010,002\",\"angleInterval\":\"015\","
                          "\"distanceInterval\":\"100\",\"gsmStrength\":\"073\",\"sequenceNumber\":\"Q263\"}",
                          timestamp_str);
            }

            snprintf(command_buffer, sizeof(command_buffer), "AT+QMTPUBEX=0,0,0,0,\"%s\",%d\r\n", g_mqtt_topic, (int)strlen(mqtt_payload));
            if (send_and_wait_for_response(command_buffer, ">", 5000)) {
                if (send_and_wait_for_response(mqtt_payload, "+QMTPUBEX: 0,0,0", 10000)) {
                    DEBUG_PRINTF("Publish OK\r\n");
                    BSP_LED_Toggle(LED_GREEN);
                } else {
                    is_connected = false;
                }
            } else {
                 is_connected = false;
            }
            if(is_connected) vTaskDelay(pdMS_TO_TICKS(1000));
        }
    }
}
/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_GPDMA2_Init();
  MX_USART2_UART_Init();
  MX_UART4_Init();
  MX_UART5_Init();
  /* USER CODE BEGIN 2 */

  BSP_LED_Init(LED_GREEN);
  BSP_LED_Init(LED_RED);

  // --- Create RTOS Objects ---
  g_debug_log_queue = xQueueCreate(DEBUG_LOG_QUEUE_LEN, sizeof(char*));
  g_uart4_rx_queue = xQueueCreate(UART4_RX_QUEUE_LEN, UART4_RX_BUFFER_SIZE + 1);
  g_gps_data_ready_sem = xSemaphoreCreateBinary();
  g_gps_data_mutex = xSemaphoreCreateMutex();

  if (!g_debug_log_queue || !g_uart4_rx_queue || !g_gps_data_ready_sem || !g_gps_data_mutex) {
      Error_Handler();
  }

  // --- Create RTOS Tasks ---
  xTaskCreate(vDebugLogTask, "DebugLog", 512, NULL, 1, NULL);
  xTaskCreate(vGpsTask, "GpsTask", 2048, NULL, 2, NULL); // Increased stack
  xTaskCreate(vMqttTask, "MqttTask", 2048, NULL, 3, NULL); // Increased stack

  DEBUG_PRINTF("\r\n--- System Initialized. Starting scheduler... ---\r\n");

  vTaskStartScheduler();

  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE0);

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLL1_SOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 4;
  RCC_OscInitStruct.PLL.PLLN = 250;
  RCC_OscInitStruct.PLL.PLLP = 2;
  RCC_OscInitStruct.PLL.PLLQ = 2;
  RCC_OscInitStruct.PLL.PLLR = 2;
  RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1_VCIRANGE_1; // FIX: Corrected typo
  RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1_VCORANGE_WIDE;
  RCC_OscInitStruct.PLL.PLLFRACN = 0;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2
                              |RCC_CLOCKTYPE_PCLK3;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB3CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
  {
    Error_Handler();
  }
}

/* USER CODE BEGIN 4 */
// The contents of your usart.c file (MX_UART_Init functions and MSP functions)
// would typically go here or in their own file. For simplicity in this single-file
// view, they are assumed to be correctly generated by CubeMX.
/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
      BSP_LED_On(LED_RED); // Turn on Red LED for permanent error
  }
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  * where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */

